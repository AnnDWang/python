#递归函数
#在函数内部可以调用其它函数。如果一个函数在内部调用自身，就是递归函数。
def fact(n):
    if(n==1):
        return 1
    return n*fact(n-1)

#上面就是一个递归函数。
fact(1)#1
fact(5)#120

#递归函数需要放置栈溢出。在计算机，函数调用是通过栈这种数据结构实现的，每当进入一个函数调用，栈会增加一层栈帧，每当函数返回，栈就减掉一层栈帧。
#由于栈的大小不是无限的，所以递归调用次数过多，会导致栈溢出。

#解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归很循环的额效果是一样的，所以把循环看成一种特殊的尾递归函数也是可以的
#尾递归是指，在函数返回的时候，调用自身本身，并且return语句不能包含表达式。这样编译器或解释器就可以把尾递归做优化，使地柜本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出
#上边的fact（n）函数由于return n*fact(n-1)引入乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，
def fact(n):
    return fact_iter(n.1

def fact_iter(num,product):
    if num==1:
        return product
    return fact_iter(num-1,num*product)
#可以看出，return fact_iter(num-1,num*product)仅仅返回递归函数本身，num-1和num*product在函数调用钱呗计算，不影响函数调用。
#尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出

